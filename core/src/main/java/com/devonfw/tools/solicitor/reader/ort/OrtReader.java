/**
 * SPDX-License-Identifier: Apache-2.0
 */

package com.devonfw.tools.solicitor.reader.ort;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.springframework.stereotype.Component;

import com.devonfw.tools.solicitor.common.PackageURLHelper;
import com.devonfw.tools.solicitor.common.SolicitorRuntimeException;
import com.devonfw.tools.solicitor.model.inventory.ApplicationComponent;
import com.devonfw.tools.solicitor.model.masterdata.Application;
import com.devonfw.tools.solicitor.model.masterdata.UsagePattern;
import com.devonfw.tools.solicitor.reader.AbstractReader;
import com.devonfw.tools.solicitor.reader.Reader;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

/**
 * A {@link Reader} which reads data generated by the <a href="https://github.com/oss-review-toolkit/ort#analyzer">ORT-Analyzer</a> component.
 */
@Component
public class OrtReader extends AbstractReader implements Reader {

  /**
   * The supported type of this {@link Reader}.
   */
  public static final String SUPPORTED_TYPE = "ort";

  /** {@inheritDoc} */
  @Override
  public Set<String> getSupportedTypes() {

    return Collections.singleton(SUPPORTED_TYPE);
  }

  /** {@inheritDoc} */
  @SuppressWarnings("rawtypes")
  @Override
  public void readInventory(String type, String sourceUrl, Application application, UsagePattern usagePattern,
      String repoType, Map<String, String> configuration) {

    int componentCount = 0;
    int licenseCount = 0;

    // According to tutorial https://github.com/FasterXML/jackson-databind/
    ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    try {
      Map l = mapper.readValue(this.inputStreamFactory.createInputStreamFor(sourceUrl), Map.class);
      Map analyzer = (Map) l.get("analyzer");
      Map result = (Map) analyzer.get("result");
      List packages = (List) result.get("packages");  
      System.out.println("packages" + packages.toString());


      for (int i = 0; i < packages.size(); i++) {
    	Map iterator = (Map) packages.get(i);
    	Map singlePackage = (Map) iterator.get("package");
		String id = (String) singlePackage.get("id"); //TODO can resolve groupid, artifactdi, version and repotype from id
		Map vcsProcessed = (Map) singlePackage.get("vcs_processed");
		String repo = (String) vcsProcessed.get("url");
		//String licenseUrl = estimateLicenseUrl(repo, path, licenseFile);
		String pURL = (String) singlePackage.get("purl");
		Map binaryArtifact = (Map) singlePackage.get("binary_artifact");
		String binaryURL = (String) binaryArtifact.get("url");
		Map sourceArtifact = (Map) singlePackage.get("source_artifact");
		String sourceURL = (String) sourceArtifact.get("url");
		String homePage = (String) singlePackage.get("homepage_url");
		if (homePage == null || homePage.isEmpty()) {
		  homePage = repo;
		}

        List lic = (List) singlePackage.get("declared_licenses");

        ApplicationComponent appComponent = getModelFactory().newApplicationComponent();
        appComponent.setApplication(application);
        componentCount++;
        //TODO resolve id into name function
        appComponent.setArtifactId(id);
        //appComponent.setVersion(version);
        appComponent.setUsagePattern(usagePattern);
        appComponent.setGroupId("test");
        appComponent.setVersion("0.0");
        appComponent.setOssHomepage(homePage);
        appComponent.setRepoType(repoType);
        appComponent.setPackageUrl(pURL);
        
        if (lic.isEmpty()) {
          // add empty raw license if no license info attached
          addRawLicense(appComponent, null, null, sourceUrl);
        } else {
          for (Object cl : lic) {
              System.out.println("full case" + cl.toString());
              System.out.println((String)cl);


            licenseCount++;
            addRawLicense(appComponent, cl.toString(), null, sourceUrl);
          }
        }     
      doLogging(sourceUrl, application, componentCount, licenseCount);
      }
    } catch (IOException e) {
      throw new SolicitorRuntimeException("Could not read ort license inventory source '" + sourceUrl + "'", e);
    }

  }

  // estimates license location in github links based on local file location
  private String estimateLicenseUrl(String repo, String path) {

    if (repo == null || repo.isEmpty()) {
      return null;
    }
    if (path == null || path.isEmpty()) {
      return repo;
    }

    if (repo.contains("github.com")) {
      String licenseRelative = path.substring(path.lastIndexOf("\\") + 1);
      if (repo.endsWith("/")) {
        repo = repo.substring(0, repo.length() - 1);
      }
      if (repo.contains("github.com")) {
        repo = repo.replace("git://", "https://");
        repo = repo.replace("github.com", "raw.githubusercontent.com");
        repo = repo.concat("/master/" + licenseRelative);
        return repo;
      }
    }
    return repo;
  }

}
