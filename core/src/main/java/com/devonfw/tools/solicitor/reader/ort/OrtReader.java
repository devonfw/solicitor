/**
 * SPDX-License-Identifier: Apache-2.0
 */

package com.devonfw.tools.solicitor.reader.ort;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import com.devonfw.tools.solicitor.common.LogMessages;
import com.devonfw.tools.solicitor.common.PackageURLHelper;
import com.devonfw.tools.solicitor.common.SolicitorRuntimeException;
import com.devonfw.tools.solicitor.common.packageurl.SolicitorMalformedPackageURLException;
import com.devonfw.tools.solicitor.model.inventory.ApplicationComponent;
import com.devonfw.tools.solicitor.model.masterdata.Application;
import com.devonfw.tools.solicitor.model.masterdata.UsagePattern;
import com.devonfw.tools.solicitor.reader.AbstractReader;
import com.devonfw.tools.solicitor.reader.Reader;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.github.packageurl.PackageURL;

/**
 * A {@link Reader} which reads data generated by the
 * <a href="https://github.com/oss-review-toolkit/ort#analyzer">ORT-Analyzer</a> component.
 */
@Component
public class OrtReader extends AbstractReader implements Reader {

  private static final Logger LOG = LoggerFactory.getLogger(OrtReader.class);

  /**
   * The supported type of this {@link Reader}.
   */
  public static final String SUPPORTED_TYPE = "ort";

  /** {@inheritDoc} */
  @Override
  public Set<String> getSupportedTypes() {

    return Collections.singleton(SUPPORTED_TYPE);
  }

  /** {@inheritDoc} */
  @SuppressWarnings("rawtypes")
  @Override
  public void readInventory(String type, String sourceUrl, Application application, UsagePattern usagePattern,
      boolean modified, String packageType, Map<String, String> configuration) {

    ReaderStatistics statistics = new ReaderStatistics();

    // According to tutorial https://github.com/FasterXML/jackson-databind/
    ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    try {
      Map l = mapper.readValue(this.inputStreamFactory.createInputStreamFor(sourceUrl), Map.class);
      Map analyzer = (Map) l.get("analyzer");
      Map result = (Map) analyzer.get("result");
      List packages = (List) result.get("packages");

      for (int i = 0; i < packages.size(); i++) {
        Map iterator = (Map) packages.get(i);
        Map singlePackage = (Map) iterator.get("package");
        String id = (String) singlePackage.get("id");
        Map vcsProcessed = (Map) singlePackage.get("vcs_processed");
        String repo = (String) vcsProcessed.get("url");
        String pURL = (String) singlePackage.get("purl");

        String homePage = (String) singlePackage.get("homepage_url");

        ApplicationComponent appComponent = getModelFactory().newApplicationComponent();
        statistics.readComponentCount++;

        // resolve id into groupId/artifactId/version/repoType
        String[] resolvedId = id.split(":");
        String trueRepoType = resolvedId[0];
        String groupId = resolvedId[1];
        String artifactId = resolvedId[2];
        String version = resolvedId[3];

        appComponent.setGroupId(groupId);
        appComponent.setArtifactId(artifactId);
        appComponent.setVersion(version);
        appComponent.setUsagePattern(usagePattern);
        appComponent.setOssModified(modified);
        appComponent.setOssHomepage(homePage);
        appComponent.setSourceRepoUrl(repo);

        try {
          if (pURL != null && !pURL.isEmpty()) {
            PackageURL packageURL = PackageURLHelper.fromString(pURL);
            appComponent.setPackageUrl(packageURL);
          }
        } catch (SolicitorMalformedPackageURLException ex) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Problem with PackageURL", ex);
          }
          LOG.warn(LogMessages.READER_PURL_MALFORMED.msg(), pURL);
        }

        if (!addComponentToApplicationIfNotFiltered(application, appComponent, configuration, statistics)) {
          // skip processing of licenses and proceed to next component if component is filtered out
          continue;
        }

        // manage multiple declared licenses
        List lic = (List) singlePackage.get("declared_licenses");
        if (lic.isEmpty()) {
          // add empty raw license if no license info attached
          addRawLicense(appComponent, null, null, sourceUrl);
        } else {
          for (Object cl : lic) {
            statistics.licenseCount++;
            addRawLicense(appComponent, cl.toString(), null, sourceUrl);
          }
        }
        doLogging(configuration, sourceUrl, application, usagePattern, modified, statistics);
      }
    } catch (IOException e) {
      throw new SolicitorRuntimeException("Could not read ort license inventory source '" + sourceUrl + "'", e);
    }
  }
}
