/**
 * SPDX-License-Identifier: Apache-2.0
 */

package com.devonfw.tools.solicitor.reader.piplicenses;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.spdx.library.LicenseInfoFactory;
import org.springframework.stereotype.Component;

import com.devonfw.tools.solicitor.common.PackageURLHelper;
import com.devonfw.tools.solicitor.common.SolicitorRuntimeException;
import com.devonfw.tools.solicitor.model.inventory.ApplicationComponent;
import com.devonfw.tools.solicitor.model.masterdata.Application;
import com.devonfw.tools.solicitor.model.masterdata.UsagePattern;
import com.devonfw.tools.solicitor.reader.AbstractReader;
import com.devonfw.tools.solicitor.reader.Reader;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

/**
 * A {@link Reader} which reads data generated by <a href="https://pypi.org/project/pip-licenses/">Pip License </a>
 */
@Component
public class PipLicensesReader extends AbstractReader implements Reader {

  /**
   * The supported type of this {@link Reader}.
   */
  public static final String SUPPORTED_TYPE = "pip";

  /** {@inheritDoc} */
  @Override
  public Set<String> getSupportedTypes() {

    return Collections.singleton(SUPPORTED_TYPE);
  }

  /** {@inheritDoc} */
  @SuppressWarnings("rawtypes")
  @Override
  public void readInventory(String type, String sourceUrl, Application application, UsagePattern usagePattern,
      String repoType, String packageType, Map<String, String> configuration) {

    ReaderStatistics statistics = new ReaderStatistics();

    // According to tutorial https://github.com/FasterXML/jackson-databind/
    ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    try {
      List l = mapper.readValue(this.inputStreamFactory.createInputStreamFor(sourceUrl), List.class);
      for (int i = 0; i < l.size(); i++) {
        Map attributes = (Map) l.get(i);
        String name = (String) attributes.get("Name");
        String version = (String) attributes.get("Version");
        String repo = (String) attributes.get("URL");
        String path = (String) attributes.get("LicenseFile");
        String licenseUrl = estimateLicenseUrl(repo, path);
        String homePage = (String) attributes.get("URL");
        // String licenseText = (String) attributes.get("LicenseText");
        String licenseMetadata = (String) attributes.get("License-Metadata");
        String licenseClassifier = (String) attributes.get("License-Classifier");
        String license;
        license = determineLicenseInfo(licenseMetadata, licenseClassifier);

        ApplicationComponent appComponent = getModelFactory().newApplicationComponent();
        statistics.readComponentCount++;
        appComponent.setArtifactId(name);
        appComponent.setVersion(version);
        appComponent.setUsagePattern(usagePattern);
        appComponent.setGroupId("");
        appComponent.setOssHomepage(homePage);
        appComponent.setRepoType(repoType);
        appComponent.setPackageUrl(PackageURLHelper.fromPyPICoordinates(name, version));

        if (!addComponentToApplicationIfNotFiltered(application, appComponent, configuration, statistics)) {
          // skip processing of licenses and proceed to next component if component is filtered out
          continue;
        }

        addRawLicense(appComponent, license, licenseUrl, sourceUrl);
        statistics.licenseCount++;
      }
      doLogging(configuration, sourceUrl, application, statistics);
    } catch (IOException e) {
      throw new SolicitorRuntimeException("Could not read pip license inventory source '" + sourceUrl + "'", e);
    }

  }

  /**
   * Determine the license information from either the license metadata field or the license classifier field.
   *
   * @param licenseMetadata the contents of the License-Metadata field
   * @param licenseClassifier the contents of the License-Classifier field
   * @return the determined license info.
   */
  String determineLicenseInfo(String licenseMetadata, String licenseClassifier) {

    String license;
    if (licenseMetadata != null && (licenseMetadata.equals("UNKNOWN") || licenseMetadata.isEmpty())) {
      licenseMetadata = null;
    }
    if (licenseClassifier != null && (licenseClassifier.equals("UNKNOWN") || licenseClassifier.isEmpty())) {
      licenseClassifier = null;
    }

    if (licenseClassifier != null && licenseMetadata != null) {
      if (LicenseInfoFactory.isSpdxListedLicenseId(licenseClassifier)) {
        license = licenseClassifier;
      } else if (LicenseInfoFactory.isSpdxListedLicenseId(licenseMetadata)) {
        license = licenseMetadata;
      } else {
        license = licenseMetadata.length() >= licenseClassifier.length() ? licenseMetadata : licenseClassifier;
      }
    } else if (licenseMetadata != null) {
      license = licenseMetadata;
    } else if (licenseClassifier != null) {
      license = licenseClassifier;
    } else {
      license = null;
    }
    return license;
  }

  // estimates license location in github links based on local file location
  private String estimateLicenseUrl(String repo, String path) {

    if (repo == null || repo.isEmpty()) {
      return null;
    }
    if (path == null || path.isEmpty()) {
      return repo;
    }

    if (repo.contains("github.com")) {
      String licenseRelative = path.substring(path.lastIndexOf("\\") + 1);
      if (repo.endsWith("/")) {
        repo = repo.substring(0, repo.length() - 1);
      }
      if (repo.contains("github.com")) {
        repo = repo.replace("git://", "https://");
        repo = repo.replace("github.com", "raw.githubusercontent.com");
        repo = repo.concat("/master/" + licenseRelative);
        return repo;
      }
    }
    return repo;
  }

}
